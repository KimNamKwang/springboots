220810
-----------
인터프리터-한 줄 해석하고 실행하고 다음줄 해석하고 실행...오류 발견시 그때 알려줌


컴파일러(C언어)-실행전에 오류가 날 만 한 부분을 미리 걸러냄
컴파일이 오래 걸리지만 컴파일 이후에는 실행시간이 빠름.


앞으로는 7zip사용하여 압축을 풀자.-알집으로는 안 풀리는 경우가 많다


cmd 창에서 폴더를 옮길때는 cd  입력
----------
220811

ctrl + F11 == Run단축키

ctrl + == 글씨크기 키우기
ctrl - == 글씨크기 줄이기

패키지 이름에서 dsad.dsads.dsad  .이 위치를 구별짓는다.
.은 자식폴더 ..은 부모폴더
package kh.java.a1; == 패키지 kh하위폴더java하위폴더a1 


import 문장은 절대로 타이핑해서 치지 마라.
package문장도 타이핑하지마라.
자동완성에 맡겨야 오류없이 자바 정식버전을 통해 제공받을 수 있음.


자바 이클립스 한 줄 주석처리는 ctrl + /  or // 

여러줄 주석 처리는 ctrl + shift + / 다만 토글링이 안되서 불편하다.

자바는 모든 파일이 class(객체의 형태 == 자료형)로 구성되어있다.

자바에서
보라색 글자 == 키워드 == 예약어
파란색 글자 == 멤버변수 이름(필드).

자바에서 메소드 == 함수. 같은 말이다

데이터타입
논리-boolean - 1byte(false가 default 값. 0외에는 모두True)
문자-char - 2byte(c에서는 1byte,  대신 출력사용가능)
-string -참조형
숫자
정수형
-byte - 1byte
-short - 2byte
-int - 4byte
-long - 8byte
실수
-float - 4byte
-double - 8byte

---------------
220812

같은 패키지하위에 소속된 것들은 import없이 사용가능.

자료형 == 클래스명
기본제공 자료형은 제외. 예약어로 만들어져있다.

클래스에서 가능한 것 {

필드 == 변수선언

메소드 정의 {
	메소드 호출() // 메소드 정의를 벗어나서는 안 된다.
	}

}


같은 패키지에 있지 않은 변수나 메소드를 사용하려면 class아래에 변수나 메소드
앞에도 public이 꼭 붙어있어야 한다. 같은 패키지면 클래스에만 붙어있으면 됌.


데이터 타입이 클래스형태인(사용자가 만든) 변수를 객체, instance, reference variable.
라고 부른다. instance를 많이 쓴다

*public으로 된 class의 이름과 파일이름은 똑같아야 한다. 즉 public 클래스는 하나만
있어야 한다. 

클래스 안에 클래스가 있는 경우 == 내부 클래스


-----------------------------
220816


자바포함 C계열 언어들은 main부터 호출

/** 주석시 자바독 활용할 것.

new는 malloc. 동적메모리 형성.

new 연산자 사용하여 뒤에 붙여줄 것은 생성자메소드.

생성자메소드를 먼저 호출해줘야 동적 메모리 공간 형성.

메소드가 호출되지 않으면 지역변수는 저장되지 않음.

static 예약어 == 필드선언시, 메소드 정의시 이 두 경우에만 사용.

main 함수는 앞에 무조건 static 선언

참조형(Heap에서 new생성자로 공간을 생성하는 경우)인 경우 저장공간의 크기는?
 4byte.
=
instance공간크기 4byte. Heap에 만들어지는 주소값의 크기 4byte.
 
임포트해서 익스포트 한 다음 copy 체크.

-----------------------------
220817


Scanner는 메모리를 사용하는게 아니라 버퍼를 사용한다. scanner는 리소스를 많이
잡아먹는다. 쓰고 close처리를 해주어야한다.


오류 발생시 들여쓰기 부분에 나오는 오류들을 call stack이라고 부른다.
콜 스택에서 나오는 오류들을 보면 스택구조로 오류난것들을 표현해줘서
아래부터 스택구조로 순서대로 올라가면서 쌓인다고 보면 된다.
오류를 수정할때는 java.util 처럼 이미 제공된 것들은 오류가 날리 없으니
스택의 제일 위에 쌓인(후입선출) 부분에서부터 시작해서 내가 만든부분을 
찾아서 수정한다.

스캐너는 리소스를 많이 잡아먹으니 여러개 만들거나 만들고 지우고 다시 만들고
등을 하게 되면 에러를 발생시킨다. 두 개씩 만들 필요도 없다.

스캐너는 지역으로 선언하려면 메소드 첫 줄에 선언하고 끝 줄에서 close해주고
필드에 올리면 가비지컬렉터가 알아서 close해준다.
다만 리소스가 많이 소모되므로 직접 close해주는 편이 좋음.

print("입력하세요 :"); 는 입력칸이 옆에 출력되고
print의 delimeter token == 구분자( ',' 로 구분)

println("입력하세요 :);  는 입력칸이 아래에 출력.
println의 delimeter token == 구분자( '엔터' 로 구분)

지역변수는 반드시 초기화해야하지만 필드는 초기화를 안하더라도 기본값이 들어감.

boolean은 false가 default값.

자평이 같고 숫자와 문자가 구별이 잘 되기 좋게 코딩폰트를 사용하는게 좋다

오버플로우 max값 다음 숫자는 가장 작은 숫자(허용범위 최솟값)로 돌아가서 담게된다
byte의 경우 127을 넘어가는 순간 -128로 표현하게된다. 

Scanner사용시 next()는 띄어쓰기 사용불가(자료 변수 참조)

*시험단골문제: 묵시적 형변환의 조건 == 크기가 작은 자료형 데이터를 크기가 큰
자료형 변수에 대입하는 경우. 교재 참조.
*시험단골문제: 보수의 계산법

String a = "3";
String b = "3";
자바 - String 타입 a == b 는 성립불가.
대신 a.equals(b) 로 써야함.


-------------------------
220818 

export-archive.

import-existing projects-finish비활성화시-copy체크박스확인.

덮어쓰기 금지.

공유문서 0819실습종합과제- **변수 연산자 제어문 과제 해서 올리기

shift 연산자
>>

양수일 경우는 빈 칸 0으로. 음수는 빈 칸 1로

switch-case문 switch(*조건식은 불가능함. 그래서 *연산식->결과값은 정수, 문자, 문자열...)

default == else의 기능.

break는 분기문, 조건문, 반복문을 탈출.

스위치-케이스 케이스 문 안에도 if문 작성가능.

p33~35까지


---------------------
220819

if 안의 break는 if 가 아닌 그 상위 반복,조건,분기문을 탈출한다


for(초기식;조건식;증감식){
~~~~;
~~~~;
continue ;밑의 수행코드들은 수행하지 않고 증감식 수행하고 조건식으로 이동한다.
~~~~;
}

배열은 같은 자료형 뿐 아니라 같은 유형의 데이터만 넣는다. (몸무게면 몸무게, 키면 키)

배열은 선언과 생성이 따로 있다. 선언한다고 공간이 생성되지는 않는다.

int[] array = new int[23]; == 선언과 동시에 생성

배열에 값을 넣을때는 {} 로. ex) String strArr[] = {"Ax", "Bx", "Cx"};

**배열 외우기
데이터타입[ ] 배열참조변수 = {값1, 값2, 값3, … };
데이터타입[ ] 배열참조변수 = new 데이터타입[ ] {값1, 값2, 값3, ….};

**자바에서는 배열만 단독으로 사용하지 않고 꼭 for문을 같이 사용한다.
**배열 조건식 (i < 배열명.length;) 로 사용

자바에서는 length가 메소드가 아니고 필드다.

** 배열의 범위 - 0~ .length-1

다차원 배열의 문법도 외워오기.

배열 자체가 주소값.

2차원 배열에 값을 넣을때는 2중 for문. 구구단처럼 위에 있는 for문을 어떤것으로
하느냐에 따라 행과 열이 바뀐다.


* 프로그래밍 언어 활용 42페이지 외우기
TestTwo 해보기


----------------------------
220822

조건식 사용시 해당하지 않는 케이스 먼저 써버리는게 가독성 좋음

*교재 p40

배열

1.얕은 복사(공유개념, 한 군데 값을 바꾸면 두 군데 다 바뀜)
2.깊은 복사(복사할 배열의 크기만큼 새로 배열 생성하여 값 대입, 한 군데
값을 바꾸면 바꾼곳만 바뀜 )
3. arraycopy메소드 활용.()


자바에서 object 는 모든것을 포함하는 자료형.

2차원 배열의 생성은 무조건 행 먼저. 그 다음이 열이다. 순서를 바꿀 수 없다
정변배열은 행과 열의 갯수가 일정하다
가변배열은 행마다 열의 갯수가 다를 수 있다. 


2차원 가변배열의 선언과 생성
int[][] arr = new int[3][]; //3행 n열의 배열 생성
arr[0] = new int[4]; // 0행은 4열
arr[1] = new int[2]; //1행은 2열
arr[2] = new int[5]; //2행은 5열

평가

프로그래밍 언어 활용 part1 - 문제해결시나리오

프로그래밍 언어 응용 part1~part2.4 까지

추상화

return이 있는 코드 아래에는 else를 잘 사용하지 않는다. 어차피 return해서 아래
는 수행하지 않기 때문

캡슐화

*교재 p45 객체지향 프로그래밍의 4가지 기술적 특징
*교재 p46 접근제한자의 종류


클래스 구조
헤더
-멤버변수선언
-멤버함수선언

-----------------------
220823

접근제한자 앞에 부호(+,~,#,-) 붙는거 외우기


클래스 다이어그램
속성 = 


abstract는 {}부분이 필요하지 않다. 추상화이기 때문에 구체적인 부분이 없다.
abstract가 있다면 그 클래스명에도 abstract를 선언해줘야한다.

호출 자동완성시
초록색 == public
s가 붙어있으면 static

***
같은 이름의
멤버변수 /  지역변수,     /부모클래스의 변수
this.변수명 / 그냥 변수명사용/ super.변수명



자식 클래스에서 public 메소드로 super. 메소드 이용하여 부모클래스의 값을
바꾸는 메소드가 있다면 다른 클래스에서도 자식 클래스의 public 메소드 이용해
최종적으로 부모클래스의 값을 변경할 수 있다.

클래스 이름 바꿀때는 rename으로

패키지를 이동할때는 refactor-move 로.


public은 하나만 존재한다.

------------------------------
220824


변수의 정의
-값을 담을 수 있는 공간. 어떤 자료형이냐에 따라 자료형이 정해진다


주석- 한 줄 주석
여러줄 주석
자바 독

변수 명명규칙- 관례와 규칙을 구분하기.

형변환
컴퓨터의 값 처리 원칙
 -같은 종류 자료형만 대입가능
 -같은종류 자료형만 계산가능
 -계산의 결과도 같은 종류의 값이 나와야함
위와 같지 않으면 형 변환이 필요함

연산자

기능에 따른 분류로 외워야함. 교재 p19

우선순위도 외워야함. 단항->이항->삼항->대입 순.


쉬프트 연산

교재 p26 TestTernary 삼항연산자 예제
시험나옴.

switch{
	case:
	if(){         //이처럼 switch case문안에도 if나 for등 중첩가능
	}for(){
	}
	break;
}

**시험문제
if를 switch문으로 바꿔보아라 반대로도.
for문을 while로 바꿔보아라 반대로도.


p35구구단도 시험.

탈출문
break는 상위의 반복문을 탈출. for, while, do-while, switch
continue는 아래에 적힌 식 수행X 조건식으로 이동. for, while, do-while 
return 상위의 메소드를 빠져나가고 호출했던 곳으로 돌아간다.

------------------------
220826

객체지향 프로그래밍

캡슐화-연관되는 필드 메소드정의 ->클래스

모듈이란? 클래스들을 모아 어떤 프로그램을 만들었을때 이를 묶어서 
모듈이라고 한다. 어떤 클래스들의 모임. 하나의 클래스일수도, 여러개일수도 있다.

생산성이 높다 = 개발기간이 짧다.

=========================
220829

메서드의 반환 값은 한개. 결과 값 하나만 반환 해준다. 두개이상의 결과 값을
받고 싶으면 하나의 자료형으로 만들어서 return시켜야 함. 이를테면 배열.
반환할 두 개 이상의 값의 자료형이 다르다면 클래스를 만들어 클래스를 반환하면
된다.

브레이크 포인트 걸어서 디버깅 할 줄 알아야 한다.

this() 는 생성자를 의미한다.

*생성자메소드호출은 메소드의 첫번째줄에 써줘야한다.
*this 메소드는 생성자 첫번째줄에 써야한다.
============
220830

this 메소드는 생성자 첫번째줄에 써야한다.

this() == 나의 생성자를 호출하는 것
super() == 부모클래스의 생성자를 호출하는 것. 안 적혀있을시 자동으로
생성된다. return같은 것.


객체배열

int arr[][] = new arr[3][4];

arr.length == 3

선언과 동시에 할당 및 초기화
Member members[] = new Member[]{new Member(), new Member()}

* toString

기본생성자 호출

this. 내 클래스에 접근
super. 부모클래스에 접근

Parent p = new Child(); 는 Child가 Override한 것을 가져다 쓴다.(주소값으로 접근)

=============
220831


다형성
1.하나의 행동으로 여러 가지 일을 수행하는 개념
2.상속을 이용해 부모 타입으로부터 파생된 여러 가지 타입의 자식 객체를
부모 클래스 타입 하나로 다룰 수 있는 기술

업 캐스팅은 다운 캐스팅이 되어 있어야 가능하다.

==================
220901

컬렉션 == 인터페이스의 종류

vector는 동기화를 제공하여 속도가 떨어지지만 데이터를 안정적으로 관리해준다.

ArrayList에도 동기화가 필요하면 syncronized예약어 붙이면 가능.

Set에는 인덱스개념이 없다.


==Map==
   키  와  값.
변수명 = 값

map에 들어있는 키 값을 알여면 iterator로 전부 뿌려서 거기서 키 값을 알아야
한다.

============
220902


(T... a) T... 는 가변인자.

<T>는 제너릭타입. 

제너릭은 자료형을 변수에 담는다는 개념이다. 집력된 자료형을 변수에 넣고
그를 자료형 자리에 넣는 느낌.

Object타입으로 모든 자료형을 받으면 값을 꺼낼때 instanceof 로 확인하고
다운캐스팅을 또 해줘야해서 비효율적임

예외처리. throws나 try-catch를 꼭 써줘야한다.

try{ }안의 오류가 발생하면 그 부분에서 멈추고 catch{ }로 이동하게 한다.



**
String inputStr = sc.nextLine();
int inputValue = Integer.parseInt(inputStr);
//문자(String)를 받으면 정수(int)로 바꾸어주는 메소드.

==========
220905

14일 시험
제어문 
배열 
구구단 
객체- oop의 3대/4대특징, 접근제한자,오버로딩,오버라이딩(220830 정리내용에 있는
예시같은 식으로.), 객체지향구조-패키지 임포트 클래스 필드
메소드 컨스트럭터 등등
생성 new 메모리 static/heap/stack
getter/setter
필드 초기화 방법 4가지의 순서
-클래스변수(static인경우, 생성자초기화가 빠짐)/ 인스턴스 변수
**(배점가장높음)클래스 다이어그램 보고 코드로 구현할 줄 알아야 함. 대문자,
기울어진 부분이 뭘 의미하는지 등.
Exception도 나옴
위 것들 많이 나옴.
=============
** 많이 씀 Wrapper클래스 String str = String.valueOf(기본자료형, 참조형);


singleton - 인스턴스마다 데이터가 필요없는 경우, 클래스 공간이 큰 경우

클래스 다이어그램
Model - 모델,예외발생시 controller로 throws
View - 보이는 화면,예외발생시 controller로 throws
Controller - 제어부, 주로 예외처리를 담당

=========
220907


공공데이터 활용 다운시에는 XML,JSON 두가지 유형이 편리

파일데이터들은 변화가 자주 없는 경우에 다운받아서 쓴다

openAPI 는 최신화가 된 데이터들을 받아올 수 있음.


PRZdTAUqyqpHImkmwwtJ8l4j7Lv6Jq%2F%2Bjdptbl6EkudAX%2B%2FE8vMpfqBBdTOeGBOcQrA4ikHgJ7hCKiti7ac3FQ%3D%3D

p92 클래스 만들고 p97까지 해보기


==================
220908

HTML
<abc> / abc == 태그

<abc> 가나다 <abc>
<def> 라마바 <def> / 가나다,라마바를 Node, 혹은 Element라고 부름

공공데이터에서 자바 샘플코드 있으면 그대로 복사해서 서비스키 부분만 
실제 서비스 키 넣고 xml파일 만들어서 콘솔창에 나온 결과값 복사후 ctrl+shift+s

==============
220913

내일 시험
*배열의 단점 1. 크기지정을 해줘야 함. 2. index중간에 삽입 불가.

그리하여 컬렉션을 사용하는 것이 낫다.

RuntimeException은(arrayoutofbounds같은) 조건식으로 예외처리를 먼저 해준다.
try-catch사용 X

대표적인 Exception 5개 외워야 함.

Throwable
    -Error

    -Exception
         -RuntimeExcepyion
	    -NullPointException -
	    -NumberFormatException -
	    -ClassCastingException - 위 3가지는 try-catch로만 가능
	    -ArithmeticException - 아래 3가지는 조건식또는 소스코드 수정으로 해결가능
                -ArrayIndexOutOfBounds-
	    -InputMismatchException

         -IOException
	    -FileNotFoundException

초기값 4단계
기본생성자(jvm 기본값) 필드 생성자 final

객체배열
문제해결 시나리오 - 클래스 다이어그램 보고 코드로 구현, 밑줄,기호,대문자(final),기울어진글자(static)
MVC - vo에는 필드가 적히고 생성자. 생성자는 기본생성자 하나, 오버로딩된 생성자,
toString, getter,setter
상속- vo extends Parentvo - 부모클래스가 기본생성자가 없다면 super()생성자가 있어야한다

다형성
-Overloading
-상속 - Parent p = new Child();

p71~72

제어문 많이 나옴. 
객체배열 get.size(), get.length, get.length; 등 구별하기
*객체배열 복사개념 나옴.
객체의 초기화 == JVM이 초기화함. null값으로 초기화 됌.
객체배열 생성자 호출하고 나서 setter getter호출 가능.
new로 객체배열 생성하지 않고 getter setter 호출하면 기본값인 null이
들어가 있기 때문에 NullPointException 발생



** 변수초기화 4가지나옴. ppt 자료 객체2에 나옴
1.JVM 기본값 초기화
2.명시적 초기화
2.초기화 블록을 이용한 초기화
4.생성자를 이용한 초기화

논리형-false
정수형 -0
실수형 - 0.0
char - 공백
String = null;

기본생성자가 없고 매개변수가 있는 생성자만 있으면
Member m = new Member() 가 안된다
Member m = new Member("홍길동", 23) 이렇게 매개변수가 있는 채로만 생성가능
try문 끝에다가 break를 걸면 정상적인 경우에만 break하고 오류발생해
catch로 빠지는 경우에는 break에 걸리지 않고 다시 처음부터 돌게된다.


sc.nextLine() 중요함
구구단, 1부터100까지의 합, 홀수합, 짝수 합

==================
220915

문제해결 시나리오 시험 1번 문제 메소드 오버로딩. 호출하는시점에는 리턴값은 상관이 없다.
매개변수가 없다면 오버로딩이 적용되지 않는다. 오버로딩시 매개변수의 자료형이
같고 갯수가 같더라도 순서가 다르다면 오버로딩이 가능하다. 

static은 대부분 public이다. 어디에서나 new로생성하지 않고 가져다 쓰기 위해서
static선언을 하는것인데 private으로 하면 목적에 맞지 않다.


3번문제 public static final String UNIT = "원";
에 대한 getter는 클래스 다이어그램에서 setter/getter를 만들라고 했으니 있는게
맞다. final이기때문에 setter는 있을 수 없다.


2씩 증가하는 코드는 i += 2, i = i + 2, 이렇게 사용가능하다.


초기화 값은 
1.JVM 기본값 초기화
2.명시적 초기화
3.초기화 블록을 이용한 초기화
4.생성자를 이용한 초기화

순으로 1-2-3-4순으로 가장 마지막에 초기화해준 값이 들어가있게된다.

static선언된 경우에는 static 초기화 블록을 따로 만들어주어야 한다.

===================
220916

** getter/setter는 변수명이 aBcdef처럼 첫 글자가 소문자 두 번째 글자가
대문자인 경우 

private int aBcDef

public int getaBcDef( ) {
	return aBcDef;
}

이렇게 이름을 ABcDef가 아닌 aBcDef 그대로 사용한다.
왜냐

데이터베이스는 대소문자를 구별하지 못해서 결국 int pclassmcount 처럼 쓰게 
되는데, 이렇게 되면 구별하기 어려워져서 이때부터 int p_class_m_count 처럼
_를 사용하게 된다.

특히 vo파일에 한해서 _를 쓰는 경우가 많다.

===============
220919

싱글스레드의 예 == 다운로드 받는 동안 아무것도 못하는 것.

멀티스레드의 예 == 다운로드 받으면서 다른일을 하는것

멀티프로세스의 예 == 인터넷 창을 두개 띄우는 일

멀티스레드가 싱글보다 빠를수도, 느릴수도 있다.

CPU가 여러개면 한번에 여러스레드가 돌아간다. 멀티 프로세스의 경우에도 그러하다

스레드는 동시처럼 보일 수는 있지만 동시성은 없다

extends thread 방법1

implements로 인터페이스를 상속받아서 만드는 방법2


main은 따로 설정하지 않으면 1~10중에 5이다.

하지만 thread는 실행하게 되면 잠깐 대기시간이 있어서 일단 main이 한 번 실행
되고나서 thread가 실행된다.

우선순위를 max를 주더라도 sleep을 걸어주면 sleep이 강제이기 때문에 sleep하는
시간동안 다른 스레드가 동작하게 된다.

우선순위는 지대한 영향을 끼치지는 않기때문에 차라리 절차지향적으로 무엇을
먼저 실행하느냐가 더 클 수도 있다. 애초에 컨트롤할 필요가 크지는 않음.


보통 생성자는 초기값설정이지만 GUI에서는 화면 초기 설정임.

상속받은 상태에서 this.abc~~ 는 자신에게 없는 abc~~ 이면 super의 abc를 의미한다.

==========================
220921

면접 단골질문 
Q.스레드가 뭔가? / A.각각의 프로그램에서 일을 진행하는 단위
Q.스레드를 사용해본 경험이 있는가? / A.교재에서 Countdown 예제.
Q.멀티쓰레드를 사용해본 경험? / A. Countdown으로 당연히 멀티 사용함.
Q.동기화란 뭔가? / A.자바에서 객체에 동시에 접근하지 못하게 하는것. 예시로는
println( ) 이 있음. 


정처기 문제집 시나공 이기적 수제비 기사패스
중에서 수제비가 제일 나은듯

www.naver.com 은 Domain. 도메인은 서버의 IP와 Port번호를 이름지은것.

http 는 protocol. 주소창에 포트번호를 생략하고 치면 protocol에 따라 기본 포트번호
사용.  포트번호는 서버가 결정한다.

=======================
220922

내 컴퓨터 주소 localHost 127.0.0.1

url 띄어쓰기 절대금물


프로토콜://인터넷주소[:포트번호][/디렉토리[/파일이름]][?쿼리스트링]

(프로토콜)
http https ftp : // (도메인 or IP)

(:포트번호) 80,21 [0~1023은 이미알려진
많이 사용중인 번호이므로 1024 65537까지 사용을 권장 ]

[/파일이름]
마지막만 파일 그 상위는 다 폴더이름.

[?쿼리스트링]
?e=f (e라는 변수에 f값을 전달.) &는 이어서 값을 전달.

url의 최대길이는 브라우저마다 다르나 보통 512정도

%뒤의 것들은 숫자나 한글을 바꾼것.


UDP는 데이터 + IP+PORT번호 까지 해서 보냄.
UDP는 실시간 미디어 처리에 특화되어있음.

7계층->5계층->4계층으로 축소되는중, 정처기 치려면 7까지 알기는 해야함.

서버소켓 생성할때 포트번호를 꼭 정해서 생성해야 한다.

===================
221005

vscode는 폴더바꿀때는 바깥에서.

깃헙-커밋 == local repository에 올리는 것.

커밋하는 방법. 파일 및 폴더 만들어서 액티브 바 - 소스 컨트롤 - 선택해서 커밋
- 푸시 
========================
221006

변수->묶음->파일->엑셀->DB(큰 용량 파일)->분산시스템(속도 향상과 안전성을 위해)

엑셀을 잘 다루면 좋다. DB 이해에도 좋음

엑셀과 DB == 엑셀은 용량이 너무 커지면 파일이 안 열린다. DB는 용량이 너무 커지면 문제가 생긴다.(CPU와 메모리 때문) 

엑셀에서 A,B,C 등 세로 한 줄은column. 1,2,3,4 등 가로 한 줄은 row. 한 칸은 cell. 한 페이지 전체는 sheet. 

한 cell에는 하나의 정보만 들어가야 한다.

컬럼(하나 이상)에서 중복이 없게 하기. - 중복되는 값이 있다면 새로운 속성을 부여한다(Unique값)
만약 하나의 컬럼에서 중복이 있다면 다른 컬럼과 합쳐서 새로운 UniqueID를 만들어 낸다.

대표값(Unique)은 숫자나 문자합성으로 만들기.


조인 - 정규화 하여 분리된 테이블끼리 Unique값을 가지고 어디에 해당하는지 찾아가는것.

구글드라이브 엑셀 시트 공유할때는 pdf로. 


=========================
221007
강사님 깃헙 위키 https://github.com/yojulab/learn_ERDs/wiki

vscode로 erd만들어서 외부로 보낼땐 export 해서 png 파일로 도출


Numeric
Date == TIMESTAMP

===========
221013

렉은 메모리에 준비가 되지 않았는데 cpu가 가져다 쓰려고 해서 생긴다.


고객등급
-고객등급코드
-고객등급코드값

상품종류
-상품종류코드
-상품종류코드값

등의 너무 작은 데이터들은 아래처럼

공통코드
-코드
-코드값
 을 만들고 고객등급코드는 고객정보에 넣어버리고 상품종류코드는 
상품정보에 넣어버리는 식으로 쓴다. == 비정규화 개념의 일부.


mysql노트북에 깔기
mysql - MySQL Installer 8.0.31 - 사이즈 큰 것. - just start download - 


====================
221014

nosql은 빅 데이터를 빠르게 담아야 할 때.

mysql server - execute - 

강사님 강의 자료 https://github.com/yojulab/learn_databases/wiki

mysql 에디터. 인터넷으로 하기 https://www.w3schools.com/mysql/default.asp

port 번호 3306 
x protocol 번호 33060

MySQL Root Password == *khacademy!

SELECT column1, column2, ... FROM table_name; == column1,2 를 table_name 테이블에서 가져오기

SELECT * ... FROM table_name; == 전부 다 가져오기

WHERE condition(조건부,if문 안의 조건식과 비슷) 

NOT조건식 쓸 때는 ( )로 감싸주는게 좋다. != 도 가능하고 나중에 해당 부분을
전체부정할때는 NOT을 쓰는게 좋다.

INNER sql 문

SELECT *
FROM Customers
WHERE Country IN (SELECT DISTINCT Country 
			FROM Customers
			WHERE CustomerID <= 20)
             		  AND City IN('London','Madrid') ;



orders 중 orderdetails Quantity가 50인 리스트


+1 : Customers 중에서 제공자(Suppliers) 나라가 UK, USA 사람은 ? 20

+2 : Customers 중에서 Orders ShipperID=2 사람들 리스트 출력 ?
83

+3 : Orders(주문자) 중 OrderDetails(주문 상세) Quantity가 50인 리스트 출력 ?


==============
221017
FROM -> WHERE -> SELECT 순으로 작동함

ctrl shift v == vscode에서 markdown 미리보기

 직원(Employees) EmployeeID가 7, 9인 종업원이 받는 주문(Orders) 총 수는 ?
Employees_Order_totals.sql

Employees
EmployeeID LastName FirstName BirthDate Photo Notes

Orders
OrderID	CustomerID EmployeeID OrderDate ShipperID



+5 : ? 분류(Categories)가 Produce, Beverages인 제품(Products) 총 갯수는 ?
Categories_Products_totals.sql

Categories
CategoryID CategoryName Description

Products
ProductID ProductName SupplierID CategoryID	Unit Price

======================
221018



supplierid 6이상 8이하이면서 price 20이상 26미만

SELECT * 
FROM Products
WHERE (SupplierID BETWEEN 6 AND 8 AND)
		(Price >= 20 AND Price < 26);

이렇게 애매할때는 ( )로 묶는것이 좋다.


BETWEEN N~M은 N이상 M이하. 미만또는 초과를 쓰려면 N과M에서 1씩 증감해주면 된다. 

WHERE 컬럼명 LIKE 'a%' 는 해당 컬럼의 a로 시작하는 모든값.
WHERE 컬럼명 LIKE '%a' 는 해당 컬럼의 a로 끝나는 모든값.
WHERE 컬럼명 LIKE '%Dollar%' 는 해당 컬럼의 Dollar가 들어간 모든 값.


String
BLOB(BinaryLargeOBject)는 파일을 넣는형식.

Numeric
FLOAT(size, d) 는 FLOAT(5, 2) 즉 000.00 d는 소수점 아래 갯수.

Date
Datetime 시작이 1000년부터 9999년까지만 가능
TimeStamp 1970년부터 2038년까지만 가능 - 그리니치 천문대 시간 + 시차로 계산됌
표시되는 건 둘 다 같음


IS NULL, IS NOT NULL 은 컬럼 값이 NULL인게 있는지 확인하는것


SELECT COUNT(ProductID)
FROM Products; 컬럼의 로우 갯수를 세주는 것. NULL값은 세지 않는다.


select
from
where
group by
having
order by
순으로

----------
SELECT *
FROM Customers
WHERE Country IN ('USA')
ORDER BY Country DESC, PostalCode; //나라는 고정인데 DESC를 걸면 그 뒤의
PostalCode가 내림차순으로 정렬됌.


SELECT SUBSTRING("SQL Tutorial", 5, 3) == 5번째 인덱스부터 3글자를 잘라낸다.


LIMIT는 페이징할때 많이 쓰임. 어디쓰던 상관 없지만 Order by 위에 쓰는게 좋음
LIMIT 3 은 결과값을 3개만 보여줌.



+ 6 : CategoryName 가 Dairy Products, Seafood이고 Price 10.00이상 50.00이하인 합계와 평균은 ?
CategoryName_Products.sql


+ 7 : CategoryName 가 Dairy Products, Seafood이고 Price 10.00이상 50.00이하인 주문 
 OrderID 내역과 총 갯수는 ?
CategoryName_Products_Order.sql  - where에 서브쿼리 두개 들어감


***group by 없이 직계함수와 같이 전체 내역을 출력할 수는 없다.

SELECT COUNT(CustomerID), Country, City
FROM Customers
GROUP BY Country, City; // country - City1
			         - City2
				로 나오게 됌. 나라의 도시별로 묶어주는것.

==========
221020
조인

주키와 외래키가 연결됐다는것 == 합집합.


* Join
+1 : users와 auths JOIIN하며, UNIQUE_ID = Paul인 것을 표시 내용은 이름, 이메일, 권한 ID ?


AUTH_NAMES.UNIQUE_ID



UNIQUE_ID_AUTH_NAMES


SELECT Products.ProductName, Categories.CategoryName
FROM Products INNER JOIN Categories
ON Products.CategoryID = Categories.CategoryID;

-- ans
Products에 CategoryID = 5,6인 것을 표시. 내용은 ProductName, SupplierName
Products_CategoryID.sql

Products -ProductName
	-Price

ProductID로 연결

OrderDetails - Quantity
제품명,가격, 주문 갯수 표시


+ 4-1: 이름, 이메일, 권한이름 표시 / 조건 이름이 'Teddy', 'Allen' ?
Users_Auth_names.sql

======================
MYSQL WorkBench


CREATE TABLE AUTH_NAMES
(
  AUTH_NAME VARCHAR(200) NOT NULL COMMENT '접근권한명',
  UNIQUE_ID VARCHAR(200) NOT NULL COMMENT '접근권한 대표값',
  PRIMARY KEY (UNIQUE_ID)
) COMMENT '접근권한명';

CREATE TABLE AUTHS
(
  UNIQUE_ID_USERS      VARCHAR(200) NOT NULL COMMENT '대표값',
  UNIQUE_ID_AUTH_NAMES VARCHAR(200) NOT NULL COMMENT '접근권한 대표값',
  PRIMARY KEY (UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
) COMMENT '권한들';

CREATE TABLE USERS
(
  UNIQUE_ID VARCHAR(200) NOT NULL COMMENT '대표값',
  NAME      VARCHAR(200) NOT NULL COMMENT '이름',
  EMAIL     VARCHAR(200) NOT NULL COMMENT '이메일',
  JOB       VARCHAR(200) NULL     COMMENT '직책',
  PRIMARY KEY (UNIQUE_ID)
) COMMENT '사용자들';

ALTER TABLE AUTHS
  ADD CONSTRAINT FK_USERS_TO_AUTHS
    FOREIGN KEY (UNIQUE_ID_USERS)
    REFERENCES USERS (UNIQUE_ID);

ALTER TABLE AUTHS
  ADD CONSTRAINT FK_AUTH_NAMES_TO_AUTHS
    FOREIGN KEY (UNIQUE_ID_AUTH_NAMES)
    REFERENCES AUTH_NAMES (UNIQUE_ID);


-- users 회원가입
INSERT INTO users(UNIQUE_ID, NAME, EMAIL, JOB)
VALUE ('U1', 'Paul', 'paul01@gmail.com', 'IT Billing')
;
INSERT INTO users(UNIQUE_ID, NAME, EMAIL, JOB)
VALUE ('U2', 'Allen', 'texas@imfblog.org', 'Engineering')
;
INSERT INTO users(UNIQUE_ID, NAME, EMAIL, JOB)
VALUE ('U3', 'Teddy', 'norway@iotm.com', 'IT Billing')
;
INSERT INTO users(UNIQUE_ID, NAME, EMAIL, JOB)
VALUE ('U4', 'Paul', 'paul_p@naver.com', 'Developer')
;

-- auth 접근권한
INSERT auth_names(AUTH_NAME, UNIQUE_ID)
VALUE ('GUEST', 'B1')
;
INSERT auth_names(AUTH_NAME, UNIQUE_ID)
VALUE ('ADMIN', 'B2')
;
INSERT auth_names(AUTH_NAME, UNIQUE_ID)
VALUE ('MANAGER', 'B3')
;

-- 접근권한들
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U1', 'B1')
;
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U1', 'B2')
;
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U2', 'B1')
;
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U2', 'B2')
;
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U2', 'B3')
;
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U3', 'B1')
;
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U4', 'B1')
;
INSERT auths(UNIQUE_ID_USERS, UNIQUE_ID_AUTH_NAMES)
VALUE ('U4', 'B2')
;

-- 회원 탈퇴

-- ---------------

-- table 확인
SELECT *
FROM users
;

SELECT *
FROM auth_names
;

SELECT *
FROM auths
;

SELECT users.NAME, users.EMAIL, AUTH_NAMES.AUTH_NAME
FROM (USERS INNER JOIN AUTHS
ON users.UNIQUE_ID = AUTHS.UNIQUE_ID_USERS
AND USERS.Name IN('Teddy', 'Allen' ) )
INNER JOIN AUTH_NAMES ON auths.UNIQUE_ID_AUTH_NAMES = AUTH_NAMES.UNIQUE_ID;
=====================

221021
- 요구사항 정의서 파악(팀원수만큼 요구사항 갯수 추가)
- ERD 작성
	+팀원 전체가 각각 만듬
	+통합
- 화면정의서 작성
- Code작성
	+Function이름만 정의된 Code작성
	+깃헙 공유와 협업 구성
	+팀별 업무 분담
	+통합 테스트
- PT

Sample - 3인이라 3개기준. 4인이면 4개
설문-
1번
이미 가입된 사람인경우를 기준으로 잡는게 좋음
2번
문항이 있고 답항이 있다.



순서-요구사항정의서작성-화면정의서(텍스트)작성-













